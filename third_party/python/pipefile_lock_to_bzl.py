#!/usr/bin/env python3
"""Transform a Pipfile.lock file to a third_party/python/requirements.bzl file."""

import argparse
import json
import os

BUILD_WORKSPACE_DIRECTORY = os.getenv("BUILD_WORKSPACE_DIRECTORY")

# The following packages are considered to be unsafe in a requirements file
_UNSAFE_PACKAGES = {"pip", "setuptools"}

_HEAD = """\"\"\"Starlark representation of locked requirements.

Generated by tools/python/pipefile_lock_to_bzl.py from {input_file}.\"\"\"

load("@rules_python//python/pip_install:pip_repository.bzl", "whl_library")
load("@rules_python//python/pip_install:repositories.bzl", "pip_install_dependencies")

_config = {{
    "enable_implicit_namespace_pkgs": False,
    "environment": {{}},
    "extra_pip_args": [],
    "isolated": True,
    "pip_data_exclude": [],
    "python_interpreter": "python3",
    "quiet": True,
    "repo": "{ns}",
    "repo_prefix": "{ns}_",
    "timeout": 600,
}}
"""

_STUB = """all_requirements = ["@{ns}_{{}}//:pkg".format(name) for name in _packages.keys()]

all_whl_requirements = ["@{ns}_{{}}//:whl".format(name) for name in _packages.keys()]

def _clean_name(name):
    return name.replace("-", "_").replace(".", "_").lower()

def requirement(name):
    return "@{ns}_" + _clean_name(name) + "//:pkg"

def whl_requirement(name):
    return "@{ns}_" + _clean_name(name) + "//:whl"

def data_requirement(name):
    return "@{ns}_" + _clean_name(name) + "//:data"

def dist_info_requirement(name):
    return "@{ns}_" + _clean_name(name) + "//:dist_info"

def entry_point(pkg, script = None):
    if not script:
        script = pkg
    return "@{ns}_" + _clean_name(pkg) + "//:rules_python_wheel_entry_point_" + script

def install_deps(**whl_library_kwargs):
    pip_install_dependencies()
    whl_config = dict(_config)
    whl_config.update(whl_library_kwargs)
    for name, pkg in _packages.items():
        requirement = "{{name}}{{version}}{{hashes}}".format(
            name=name,
            version=pkg['version'],
            hashes=''.join(['     --hash={{}}'.format(h) for h in pkg['hashes']])
        )
        if "markers" in pkg:
            requirement += " ; " + pkg["markers"].replace("\'", '"')
        whl_library(
            name = "{ns}_{{}}".format(name),
            requirement = requirement,
            **whl_config
        )
"""


def _clean_name(name):
    return name.replace("-", "_").replace(".", "_").lower()


def data(lock):
    for k, v in sorted((lock["default"] | lock["develop"]).items()):
        if k in _UNSAFE_PACKAGES:
            continue
        yield k, v


def main():
    if BUILD_WORKSPACE_DIRECTORY:
        os.chdir(BUILD_WORKSPACE_DIRECTORY)

    parser = argparse.ArgumentParser()
    parser.add_argument("input", help="Pipfile.lock file path")
    parser.add_argument("--namespace", default="pip")
    parser.add_argument("--output")
    args = parser.parse_args()

    with open(args.input) as f:
        lock = json.load(f)

    out = _HEAD.format(ns=args.namespace, input_file=args.input)
    out += "\n_packages = {\n"
    for k, v in data(lock):
        out += f'    "{_clean_name(k)}": {{\n'
        out += '        "hashes": [\n'
        for hash in v["hashes"]:
            out += f'            "{hash}",\n'
        out += "        ],\n"
        if "markers" in v.keys():
            out += f"        \"markers\": \"{v['markers']}\",\n"
        out += f"        \"version\": \"{v['version']}\",\n"
        out += "    },\n"
    out += "}\n\n"
    out += _STUB.format(ns=args.namespace)

    if args.output:
        with open(args.output, "w") as f:
            print(out, end="", file=f)
    else:
        print(out, end="")


if __name__ == "__main__":
    main()
